#+TITLE:     rc.lua.org
#+AUTHOR:    Rainer M. Krug
#+EMAIL:     Rainer@krugs.de
#+DATE:      2012-05-11 Fri
#+DESCRIPTION:
#+KEYWORDS:

:CONFIG:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:
#+DRAWERS: HIDDEN PROPERTIES STATE CONFIG BABEL OUTPUT LATEXHEADER
#+STARTUP: hidestars hideblocks

#+OPTIONS: ^:{}
:END:

:LATEXHEADER:
#+LATEX_HEADER: \usepackage{rotfloat}
#+LATEX_HEADER: \definecolor{light-gray}{gray}{0.9}
#+LATEX_HEADER: \lstset{%
#+LATEX_HEADER:     basicstyle=\ttfamily\tiny,       % the font that is used for the code
#+LATEX_HEADER:     tabsize=4,                       % sets default tabsize to 4 spaces
#+LATEX_HEADER:     numbers=left,                    % where to put the line numbers
#+LATEX_HEADER:     numberstyle=\tiny,               % line number font size
#+LATEX_HEADER:     stepnumber=0,                    % step between two line numbers
#+LATEX_HEADER:     breaklines=true,                 %!! don't break long lines of code
#+LATEX_HEADER:     showtabs=false,                  % show tabs within strings adding particular underscores
#+LATEX_HEADER:     showspaces=false,                % show spaces adding particular underscores
#+LATEX_HEADER:     showstringspaces=false,          % underline spaces within strings
#+LATEX_HEADER:     keywordstyle=\color{blue},
#+LATEX_HEADER:     identifierstyle=\color{black},
#+LATEX_HEADER:     stringstyle=\color{green},
#+LATEX_HEADER:     commentstyle=\color{red},
#+LATEX_HEADER:     backgroundcolor=\color{light-gray},   % sets the background color
#+LATEX_HEADER:     columns=fullflexible,  
#+LATEX_HEADER:     basewidth={0.5em,0.4em}, 
#+LATEX_HEADER:     captionpos=b,                    % sets the caption position to `bottom'
#+LATEX_HEADER:     extendedchars=false              %! workaround for when the listed file is in UTF-8
#+LATEX_HEADER: }
#+LATEX_HEADER: \usepackage{attachfile2}
:END:

* General modules
** TODO Autostart
Let's use it again to make awesome more portable
Some references:
- policykit :: [[notmuch:id:50ED7F0B.8080303@gmail.com][Email from Rainer M. Krug: policykit]]
#+header: :tangle ./autostart.sh
#+begin_src sh
  #!/bin/bash
  ## Just to make sure, source .bash_profile and .bashrc
  source ~/.bashstart &
  
  ###################
  ## start gnome-settings-daemon
  gnome-settings-daemon &
  ###################
  ## start gnome keyring
  /usr/bin/gnome-keyring-daemon --start --components=pkcs11,secrets,ssh,gpg &
  export GNOME_KEYRING_SOCKET
  export GNOME_KEYRING_PID
  export GNOME_KEYRING_CONTROL
  export SSH_AUTH_SOC
  export GPG_AGENT_INFO
  ###################
  ## start udisks-glue to enable automount
  run_once udisks-glue
  ## use policykit to deal with passwordpromt when starting e.g. synaptic
  /usr/lib/policykit-1-gnome/polkit-gnome-authentication-agent-1 &
  ####################
  ## start recollindex usin ionice Idle
  ionice -c 3 recollindex -m
  ###################
  ## start emacs daemon
  run_once emacs --daemon
  ###################
  
  
  ###################
  ## run redshift for actual location
  gtk-redshift -l 48.570236:1.963693 &
  ###################
  ## start network applett
  # wicd-gtk &
  run_once nm-applet
  ###################
  ## start gnome-do
  run_once gnome-do
  ###################
  ## start bluetooth-applets
  run_once bluetooth-applet
  run_once blueman-applet
  ###################
  ## start spideroak
  run_once SpiderOak
  ###################
  ## start dropbox daemon
  run_once dropboxd
  ###################
  ## start skype
  run_once skype
  ###################
  ## start cryptkeeper
  run_once cryptkeeper
  ###################
  ## start radiotray webradio player
  run_once radiotray
  ###################
  
  
  ###################
  ## set background
  nitrogen --restore &
  ###################
  
  ###################
  ## start conky
  run_once conky -c /home/rkrug/.conky/conkyrc
  ###################
  
  ###################
  ## start calendar indicatorr
  run_once calendar-indicator
  ###################
  
  # # ~/bin/adjustMonitor
  
  # ## Just to make sure, source .bash_profile and .bashrc
  # ## source ~/.bash_profile &
  # ## source ~/.bashrc &
  
  # ###################
  # ## start avant window manager
  # avant-window-navigator &
  # ###################
  # ## set caps lock as compose key
  # setxkbmap -option compose:caps &
  # ###################
  # ## disable touchpad when typing
  # syndaemon -d -i 2 &
  # ###################
  # ## autostart using Freedesktop specifications 
  #  # fbautostart &
  # ###################
  # ## start gnome volume control
  #  # gnome-volume-control-applet &
  # ###################
  # ## start gnome power manager
  #  # gnome-power-manager &
  # ###################
  # ## start ejecter
  #  # ejecter &
  # ###################
  # ## start screenlets
  #  # screenlets-daemon &
  # ###################
  # ## start workrave
  # workrave &
  # ###################
  # ## start tasque for management of RTM
  #  # tasque &
  # ###################
  # ## start qwit twitter client
  # # qwit &
  # ###################
  # ## start mail-notification
  #  # mail-notification &
  # ###################
  # ## start guake
  # ## run_once guake & 
  ###################
#+end_src

** variabledefinitions.lua
:PROPERTIES:
:tangle:  ./variabledefinitions.lua
:END:
*** Default modkey
#+begin_src lua
  -- {{{ Variable definitions
  -- Default modkey.
  modkey = "Mod4"
  altkey = "Mod1"
#+end_src
*** Environment programs
#+begin_src lua
  -- Environment programs
  env = {
     browser = "chromium-browser ",
     email = "emacs --name Mail --title Mail --no-desktop --no-splash --funcall gnus ",
     man = "xterm -e man ",
     terminal = "xterm ", 
     grass7 = "xterm -title 'GRASS 7'",
     grass = "xterm -title 'GRASS'",
     -- screen = "xterm -e screen",
     fileman = "nautilus",
     terminal_root = "xterm -e su -c screen",
     im = "pidgin ",
     editor = os.getenv("EDITOR") or "ec ",
     home_dir = os.getenv("HOME"),
     music_show = "gmpc --replace",
     music_hide = "gmpc --quit",
     run = "gmrun",
     locker = "gnome-screensaver-command --activate",
     xkill = "xkill",
     poweroff = "sudo /sbin/poweroff",
     reboot = "sudo /sbin/reboot",
     hibernate = "sudo /usr/sbin/pm-hibernate",
     suspend = "sudo /usr/sbin/pm-suspend",
     logoutGnome = "/usr/bin/gnome-session-quit",
     rotate = "rotator",
     rfkill = { 
        wifi = "sudo /usr/local/bin/laptop-net wifi", 
        wimax = "sudo /usr/local/bin/laptop-net wimax",
        off = "sudo /usr/local/bin/laptop-net off"},
     syslog = "urxvt -e vim -T xterm-256color /var/log/messages",
     volumecontrol = "pavucontrol ",
     skype = "skype ",
     apps = "xfce4-appfinder",
  }
#+end_src

*** Table of layouts
#+begin_src lua
  -- Table of layouts to cover with awful.layout.inc, order matters.
  layouts = 
     {
     awful.layout.suit.floating,
     awful.layout.suit.tile,
     -- awful.layout.suit.tile.left,
     awful.layout.suit.tile.bottom,
     -- awful.layout.suit.tile.top,
     awful.layout.suit.fair,
     -- awful.layout.suit.fair.horizontal,
     -- awful.layout.suit.spiral.dwindle,
     -- awful.layout.suit.max.fullscreen,
     awful.layout.suit.magnifier,
     awful.layout.suit.spiral,
     awful.layout.suit.max,
     }
#+end_src

** functiondefinitions.lua
:PROPERTIES:
:tangle:  ./functiondefinitions.lua
:END:
*** fullscreens
Function to spread window over both monitors. See [[http://awesome.naquadah.org/wiki/FullScreens]] for details.
#+begin_src lua
  function fullscreens(c)
       awful.client.floating.toggle(c)
       if awful.client.floating.get(c) then
           local clientX = screen[1].workarea.x
           local clientY = screen[1].workarea.y
           local clientWidth = 2147483640
           -- look at http://www.rpm.org/api/4.4.2.2/llimits_8h-source.html
           local clientHeight = 0
           for s = 1, screen.count() do
               clientHeight = clientHeight + screen[s].workarea.height
               clientWidth = math.min(clientWidth, screen[s].workarea.width)
           end
           local t = c:geometry({x = clientX, y = clientY, width = clientWidth, height = clientHeight})
       else
           --apply the rules to this client so he can return to the right tag if there is a rule for that.
           awful.rules.apply(c)
       end
       -- focus our client
       client.focus = c
   end
#+end_src
*** XRandR screen table
see http://awesome.naquadah.org/wiki/XRandR_Screen_Table for details
#+begin_src lua
  awful.util.spawn_with_shell("xrandr -q >/home/rkrug/.config/awesome/xrandrtable")
  function xrandr_screens ()
     local screens = {}
     local counter = 1
     local handle = io.popen("cat /home/rkrug/.config/awesome/xrandrtable")
     for display in handle:read("*all"):gmatch("([%a%d-]+) connected") do
        screens[display] = counter
        counter = counter + 1
     end
     handle:close()
     return screens
  end
  screens = xrandr_screens()
#+end_src

** globalkeys.lua
:PROPERTIES:
:tangle:  ./globalkeys.lua
:END:
*** Begin
#+begin_src lua 
  globalkeys = awful.util.table.join(
#+end_src
*** Application hotkeys
#+begin_src lua
  -- Application hotkeys
  awful.key({ modkey,           }, "Return", function () awful.util.spawn(env.terminal) end),
  awful.key({ modkey            }, "b", function () awful.util.spawn(env.browser) end),
  awful.key({ modkey            }, "e", function () awful.util.spawn(env.email)  end),
  awful.key({ modkey,           }, "k", function () awful.util.spawn(env.locker) end),
  awful.key({ modkey            }, "r", function () mypromptbox[mouse.screen]:run() end),
  awful.key({ modkey, altkey    }, "r", function () awful.util.spawn(env.run) end),
  -- awful.key({ modkey,           }, "m", function () run_or_raise("gmpc", { class = "Gmpc" }) end),
  awful.key({ modkey            }, "p", function () awful.util.spawn(env.im) end),
  -- awful.key({ modkey            }, "c", function () run_or_raise("xterm -e calc", { class="XTerm", name = "calc" }) end),
  awful.key({ modkey,           }, "d", function () awful.util.spawn(env.editor) end),
  awful.key({ modkey,           }, "v", function () awful.util.spawn(env.volumecontrol) end),
  awful.key({ modkey,           }, "x", function () awful.util.spawn(env.apps) end),
#+end_src
*** Awesome control
#+begin_src lua
  -- Awesome control
  awful.key({ modkey, "Control" }, "q", awesome.quit),
  awful.key({ modkey, "Control" }, "r", function() mypromptbox[mouse.screen].widget.text = awful.util.escape(awful.util.restart()) end),
#+end_src

*** Client manipulations
#+begin_src lua
  -- Client manipulation
  awful.key({ altkey            }, "j", function () switch_to_client(-1) end),
  awful.key({ altkey            }, "k", function () switch_to_client(1) end),
  awful.key({ altkey            }, "1", function () switch_to_client(-1) end),
  awful.key({ altkey            }, "2", function () switch_to_client(1) end),
  awful.key({ modkey, "Shift"   }, "j", function () awful.client.swap.byidx(1) end),
  awful.key({ modkey, "Shift"   }, "k", function () awful.client.swap.byidx(-1) end),
  -- awful.key({ altkey            }, "Tab", function() switch_to_client(0) end),
#+end_src

*** Layout manipulation
#+begin_src lua
  -- Layout manipulation
  awful.key({ modkey,           }, "Left",   awful.tag.viewprev       ),
  awful.key({ modkey,           }, "Right",  awful.tag.viewnext       ),
  
  awful.key({ modkey, "Shift"   }, "Left", 
            function() 
               local s = mouse.screen == 1 and 2 or 1
               awful.tag.viewprev(screen[s])
            end), -- on other screen
  awful.key({ modkey, "Shift"   }, "Right", 
            function() 
               local s = mouse.screen == 1 and 2 or 1
               awful.tag.viewnext(screen[s])
            end), -- on other screen
  
  awful.key({ modkey,           }, "h", function () awful.tag.incmwfact(-0.05) end),
  awful.key({ modkey,           }, "l", function () awful.tag.incmwfact(0.05) end),
  awful.key({ modkey, "Shift"   }, "h", function () awful.tag.incnmaster(1) end),
  awful.key({ modkey, "Shift"   }, "l", function () awful.tag.incnmaster(-1) end),
  awful.key({ modkey, "Control" }, "h", function () awful.tag.incncol(1) end),
  awful.key({ modkey, "Control" }, "l", function () awful.tag.incncol(-1) end),

  awful.key({ modkey,           }, "space", function () awful.layout.inc(layouts, 1) end),
  awful.key({ modkey, "Shift"   }, "space", function () awful.layout.inc(layouts, -1) end),
  -- awful.key({ altkey,           }, "e", function () myrc.keybind.push_menu(chord_mpd(), chord_menu_args) end),
#+end_src

*** Multimedia keys
#+begin_src lua
  -- Multimedia keys
  awful.key({ }, "XF86AudioRaqiseVolume", function () awful.util.spawn("pactl -- set-sink-volume 0 +10%") end),
  awful.key({ }, "XF86AudioLowerVolume", function () awful.util.spawn("pactl -- set-sink-volume 0 -10%") end),
  awful.key({ }, "XF86AudioMute", function () awful.util.spawn("") end)
#+end_src

*** End
#+begin_src lua 
  )
#+end_src

** clientkeys.lua
:PROPERTIES:
:tangle:  ./clientkeys.lua
:END:
#+begin_src lua  
  clientkeys = awful.util.table.join( 
     awful.key({ modkey }, "F1", 
               function (c) 
                  local tag = myrc.tagman.getn(-1)
                  awful.client.movetotag(tag, c)
                  awful.tag.viewonly(tag)
                  c:raise()
               end),
     awful.key({ modkey }, "F2", 
               function (c) 
                  local tag = myrc.tagman.getn(1)
                  awful.client.movetotag(tag, c)
                  awful.tag.viewonly(tag)
                  c:raise()
               end),
     awful.key({ modkey,           }, "f",      function (c) c.fullscreen = not c.fullscreen  end),
     awful.key({ modkey, "Control" }, "f",      fullscreens),
     awful.key({ modkey, "Shift"   }, "c",      function (c) c:kill()                         end),
     awful.key({ modkey,           }, "a",  awful.client.floating.toggle                     ),
     awful.key({ modkey, "Control" }, "Return", function (c) c:swap(awful.client.getmaster()) end),
     awful.key({ modkey,           }, "o",      awful.client.movetoscreen                        ),
     awful.key({ modkey, "Shift"   }, "r",      function (c) c:redraw()                       end),
     awful.key({ modkey,           }, "n",      function (c) c.minimized = not c.minimized    end),
     -- awful.key({ altkey,           }, "h",      function (c) .maximized_horizontal = not c.maximized_horizontal  end),
     -- awful.key({ altkey,           }, "v",      function (c) .maximized_vertical = not c.maximized_vertical  end),
     awful.key({ modkey }, "m", 
               function (c)
                  c.maximized_horizontal = not c.maximized_horizontal
                  c.maximized_vertical   = not c.maximized_vertical
               end)
  
                                    )
#+end_src

** clientbuttons.lua
:PROPERTIES:
:tangle:  ./clientbuttons.lua
:END:
#+begin_src lua
  clientbuttons = awful.util.table.join(
     awful.button({ }, 1, function (c) client.focus = c; c:raise() end),
     awful.button({ modkey }, 1, awful.mouse.client.move),
     awful.button({ modkey }, 3, awful.mouse.client.resize)
                                       )
#+end_src

** hooks.lua
:PROPERTIES:
:tangle:  ./hooks.lua
:END:
*** Fousing client
#+begin_src lua 
  -- Hook function to execute when focusing a client.
  client.add_signal("focus", 
                    function (c)
                       c.border_color = beautiful.border_focus;
                       c.opacity = 1.0
                    end)
#+end_src
*** Unfocusing client
#+begin_src lua 
  -- Hook function to execute when unfocusing a client.
  client.add_signal("unfocus", 
                    function (c)
                       c.border_color = beautiful.border_normal;
                       c.opacity = 0.9
                    end)
  
#+end_src
*** mouse_enter
#+begin_src lua 
  awful.hooks.mouse_enter.register(
     function (c)
        -- Sloppy focus, but disabled for magnifier layout
        if awful.layout.get(c.screen) ~= awful.layout.suit.magnifier
           and awful.client.focus.filter(c) then
        client.focus = c
        end
     end)
#+end_src

** widgets.lua
:PROPERTIES:
:tangle:  ./widgets.lua
:END:
*** Clock
#+begin_src lua
  -- Clock
  mytextclock = {}
  mytextclock = widget({ type = "textbox", align="right" })
  pipelets.register_fmt(mytextclock, "date", " $1 ")
#+end_src
*** Mountbox
#+begin_src lua
  -- Mountbox
  mymountbox = widget({ type = "textbox", align="right" })
  pipelets.register_fmt( mymountbox, "mmount", " $1")
#+end_src
*** BatteryBox
#+begin_src lua
  -- BatteryBox
  mybatbox = widget({ type = "textbox", align="right" })
  pipelets.register( mybatbox, "batmon")
#+end_src
*** Temp
#+begin_src lua
  -- Temp
  mytemp = widget({ type = "textbox", align="right" })
  pipelets.register_fmt( mytemp, "temp", " $1 ")
#+end_src

** keydoc
From [[http://awesome.naquadah.org/wiki/Document_keybindings]]:

It is sometimes difficult to remember some keybindings. You have to check in your rc.lua. The module below monkey-patch awful.key to add a documentation string to a keybinding. It also has a function to display a naugthy notification with all valid (global and window-related) documented keybindings. 
#+header: :tangle ./keydoc.lua
#+begin_src lua
  local awful     = require("awful")
  local table     = table
  local ipairs    = ipairs
  local pairs     = pairs
  local math      = math
  local string    = string
  local type      = type
  local modkey    = "Mod4"
  local beautiful = require("beautiful")
  local naughty   = require("naughty")
  local capi      = {
     root = root,
     client = client
  }
  
  module("keydoc")
  
  local doc = { }
  local currentgroup = "Misc"
  local orig = awful.key.new
  
  -- Replacement for awful.key.new
  local function new(mod, key, press, release, docstring)
     -- Usually, there is no use of release, let's just use it for doc
     -- if it's a string.
     if press and release and not docstring and type(release) == "string" then
        docstring = release
        release = nil
     end
     local k = orig(mod, key, press, release)
     -- Remember documentation for this key (we take the first one)
     if k and #k > 0 and docstring then
        doc[k[1]] = { help = docstring,
                      group = currentgroup }
     end
  
     return k
  end
  awful.key.new = new             -- monkey patch
  
  -- Turn a key to a string
  local function key2str(key)
     local sym = key.key or key.keysym
     local translate = {
        ["#14"] = "#",
        [" "] = "Space",
     }
     sym = translate[sym] or sym
     if not key.modifiers or #key.modifiers == 0 then return sym end
     local result = ""
     local translate = {
        [modkey] = "⊞",
        Shift    = "⇧",
        Control  = "Ctrl",
     }
     for _, mod in pairs(key.modifiers) do
        mod = translate[mod] or mod
        result = result .. mod .. " + "
     end
     return result .. sym
  end
  
  -- Unicode "aware" length function (well, UTF8 aware)
  -- See: http://lua-users.org/wiki/LuaUnicode
  local function unilen(str)
     local _, count = string.gsub(str, "[^\128-\193]", "")
     return count
  end
  
  -- Start a new group
  function group(name)
     currentgroup = name
     return {}
  end
  
  local function markup(keys)
     local result = {}
  
     -- Compute longest key combination
     local longest = 0
     for _, key in ipairs(keys) do
        if doc[key] then
           longest = math.max(longest, unilen(key2str(key)))
        end
     end
  
     local curgroup = nil
     for _, key in ipairs(keys) do
        if doc[key] then
           local help, group = doc[key].help, doc[key].group
           local skey = key2str(key)
           result[group] = (result[group] or "") ..
              '<span font="DejaVu Sans Mono 10" color="' .. beautiful.fg_widget_clock .. '"> ' ..
              string.format("%" .. (longest - unilen(skey)) .. "s  ", "") .. skey ..
              '</span>  <span color="' .. beautiful.fg_widget_value .. '">' ..
              help .. '</span>\n'
        end
     end
  
     return result
  end
  
  -- Display help in a naughty notification
  local nid = nil
  function display()
     local strings = awful.util.table.join(
        markup(capi.root.keys()),
        capi.client.focus and markup(capi.client.focus:keys()) or {})
  
     local result = ""
     for group, res in pairs(strings) do
        if #result > 0 then result = result .. "\n" end
        result = result ..
           '<span weight="bold" color="' .. beautiful.fg_widget_value_important .. '">' ..
           group .. "</span>\n" .. res
     end
     nid = naughty.notify({ text = result,
                            replaces_id = nid,
                            hover_timeout = 0.1,
                            timeout = 30 }).id
  end
#+end_src

You just need to import the module and add a docstring for any keybinding you want to document.
#+header: :tangle no
#+begin_src lua 
  local keydoc = require("keydoc")
  
  -- [...]
     keydoc.group("Layout manipulation"),
     awful.key({ modkey, "Shift"   }, "j", function () awful.client.swap.byidx(  1)    end,
               "Swap with next window"),
     awful.key({ modkey, "Shift"   }, "k", function () awful.client.swap.byidx( -1)    end,
               "Swap with previous window"),
  -- [...]
     keydoc.group("Misc"),
     awful.key({ modkey,           }, "Return", function () awful.util.spawn(config.terminal) end,
               "Spawn a terminal"),
  -- [...]
     awful.key({ modkey, }, "F1", keydoc.display)
#+end_src
** runonce.lua
Run an application only once during one awesome session. See [[http://awesome.naquadah.org/wiki/Autostart#PID_way]] for details
#+header: :tangle ./runonce.lua
#+BEGIN_SRC lua
  -- @author Peter J. Kranz (Absurd-Mind, peter@myref.net)
  -- Any questions, criticism or praise just drop me an email
  
  local M = {}
  
  -- get the current Pid of awesome
  local function getCurrentPid()
     -- get awesome pid from pgrep
     local fpid = io.popen("pgrep -u " .. os.getenv("USER") .. " -o awesome")
     local pid = fpid:read("*n")
     fpid:close()
  
     -- sanity check
     if pid == nil then
        return -1
     end
  
     return pid
  end
  
  local function getOldPid(filename)
     -- open file
     local pidFile = io.open(filename)
     if pidFile == nil then
        return -1
     end
  
     -- read number
     local pid = pidFile:read("*n")
     pidFile:close()
  
     -- sanity check
     if pid <= 0 then
        return -1
     end
  
     return pid;
  end
  
  local function writePid(filename, pid)
     local pidFile = io.open(filename, "w+")
     pidFile:write(pid)
     pidFile:close()
  end
  
  local function shallExecute(oldPid, newPid)
     -- simple check if equivalent
     if oldPid == newPid then
        return false
     end
  
     return true
  end
  
  local function getPidFile()
     local host = io.lines("/proc/sys/kernel/hostname")()
     return awful.util.getdir("cache") .. "/awesome." .. host .. ".pid"
  end
  
  -- run Once per real awesome start (config reload works)
  -- does not cover "pkill awesome && awesome"
  function M.run(shellCommand)
     -- check and Execute
     if shallExecute(M.oldPid, M.currentPid) then
        awful.util.spawn_with_shell(shellCommand)
     end
  end
  
  M.pidFile = getPidFile()
  M.oldPid = getOldPid(M.pidFile)
  M.currentPid = getCurrentPid()
  writePid(M.pidFile, M.currentPid)
  
  return M
#+END_SRC


* New shifty config file (rc.lua)
Shifty example configuration file
:PROPERTIES:
:tangle: ./rc.lua
:END:
** loading libraries
#+begin_src lua 
  -- default rc.lua for shifty
  --
  -- Standard awesome library
  require("awful")
  -- Theme handling library
  require("beautiful")
  -- Notification library
  require("naughty")
  -- shifty - dynamic tagging library
  require("shifty")

  -- Load Debian menu entries
  -- require("debian.menu")  
  
  -- load runonce.lua
  local r = require("runonce")
#+end_src 
** Debugging stuff
#+begin_src lua
  -- useful for debugging, marks the beginning of rc.lua exec
  print("Entered rc.lua: " .. os.time())
#+end_src 

** Theming
*** Theme path
#+begin_src lua  
  -- Variable definitions
  -- Themes define colours, icons, and wallpapers
  -- The default is a dark theme
  theme_path = "/home/rkrug/.config/awesome/themes/default/theme.lua"
  -- Uncommment this for a lighter theme
  -- theme_path = "/usr/share/awesome/themes/sky/theme"
#+end_src 
*** load theme 
  #+begin_src lua
    beautiful.init(theme_path)
#+end_src 
** Variable definitions
*** Define config paths
#+begin_src lua 
  config = awful.util.getdir("config")
#+end_src

*** Load ./module/variabledefinitions.lua
#+begin_src lua 
  dofile(config .. "/variabledefinitions.lua")
#+end_src

** Load Function definitions
#+begin_src lua 
  dofile(config .. "/functiondefinitions.lua")
#+end_src

** Use titlebar
 #+begin_src lua
     -- Define if we want to use titlebar on all applications.
     use_titlebar = false
  #+end_src 
** Shifty configured tags
#+begin_src lua
  -- Shifty configured tags.
  shifty.config.tags = {
     --Screen 1--
     s1 = {
        layout    = awful.layout.suit.floating,
        exclusive = false,
        screen    = 1,
        position  = 1,
        init      = true,
        slave     = false,
        persist = true,
     },
     mail = {
        layout    = awful.layout.suit.tile,
        mwfact    = 0.55,
        exclusive = false,
        position  = 2,
        screen    = 1,
        spawn     = env.email,
        slave     = true
     },
     VM = {
        layout    = awful.layout.suit.tile,
        mwfact    = 0.55,
        exclusive = false,
        screen    = 1,
        slave     = false
     },
     media = {
        layout    = awful.layout.suit.float,
        screen    = 1,
        exclusive = false,
        position  = 9,
        slave     = true
     },
     emacs = {
        layout   = awful.layout.suit.tile,
        exclusive = false,
        position = 11,
        screen    = 1,
        slave    = true,
        spawn    = env.editor,
        exclusive = false,
     },
    --Screen 2--
     s2 = {
        layout    = awful.layout.suit.floating,
        exclusive = false,
        screen    = math.max(screen.count(), 1),
        position  = 1,
        init      = true,
        slave     = false,
        persist = true,
     },
     IM = {
        layout      = awful.layout.suit.tile,
        mwfact      = 0.65,
        exclusive   = false,
        screen      = math.max(screen.count(), 1),
        position    = 2,
        spawn       = env.im
     },
     web = {
        layout      = awful.layout.suit.tile,
        mwfact      = 0.65,
        exclusive   = false,
        screen      = math.max(screen.count(), 1),
        position    = 3,
        spawn       = env.browser,
     },
     grass = {
        layout      = awful.layout.suit.tile,
        mwfact      = 0.65,
        exclusive   = false,
        screen      = math.max(screen.count(), 1),
        position    = 10,
        spawn       = env.grass7,
     },
     --Wherever--
     office = {
        layout   = awful.layout.suit.tile,
        position = 9,
        persist  = true,
        init     = false,
     },
     GIS = {
        layout   = awful.layout.suit.tile,
        position = 10,
        persist = true,
        init      = false,
     },
  }
  #+end_src 
** Shifty application matching rules   
#+begin_src lua
  -- SHIFTY: application matching rules
  -- order here matters, early rules will be applied first
  shifty.config.apps = {
     {
        match = {
           "emacs@ecolmod",
           "Emacs",
           "emacs"
        },
        tag = "emacs"
     },
     {
        match = {
           -- "Navigator",
           "Vimperator",
           "Gran Paradiso",
           "Firefox", 
           "chromium-browser",
           "Chromium-browser",
           "chromium",
           "Chromium",
           "midori",
           "Midori",
           "Navigator", 
           "Conkeror"
        },
        tag = "web",
     },
     {
        match = {
           "Mail",
           "Shredder.*",
           "Thunderbird",
           "Thunderbird*",
           "thunderbird",
           "mutt",
           "Zimbra Desktop",
           "Zimbra*",
           "Pan"
        },
        tag = "mail",
     },
     {
        match = {
           "GRASS GIS",
           "GRASS 7",
           "GRASS",
        },
        tag = "grass",
     },
     {
        match = {
           "qgis",
           "Qgis"
        },
        tag = "GIS",
     },
     {
        match = {
           "Pidgin",
           "Skype",
        },
        tag = "IM",
     },
     {
        match = {
           "pcmanfm",
        },
        slave = true
     },
     {
        match = {
           "VirtualBox",
        },
        tag = "VM"
     },
     {
        match = {
           "libreoffice-*",
           "LibreOffice",
           "Abiword",
           "Gnumeric",
           "Lyx",
           "WINWORD.EXE",
           "POWERPNT.EXE",
           "mendeleydesktop", 
           "Mendeleydesktop",
           "Mendeley Desktop",
        },
        tag = "office",
     },
     {
        match = {
           "Mplayer.*",
           "Mirage",
           "gimp",
           "gtkpod",
           "Ufraw",
           "easytag",
           "banshee",
           "Banshee",
           "amarok",
           "Amarok",
           "MusicBrainz Picard", 
           "spotify", 
           "Spotify",
           "google-musicmanager", 
           "Google-musicmanager",
           "xscanimage", 
           "Xscanimage"
        },
        tag = "media",
        -- nopopup = true,
     },
     {
        match = {
           "MPlayer",
           "Gnuplot",
           "galculator",
        },
        float = true,
     },
     {
        match = {
           env.terminal,
        },
        honorsizehints = false,
        slave = true,
     },
     {
        match = {""},
        buttons = awful.util.table.join(
           awful.button({}, 1, function (c) client.focus = c; c:raise() end),
           awful.button({modkey}, 1, function(c)
                           client.focus = c
                           c:raise()
                           awful.mouse.client.move(c)
                                     end),
           awful.button({modkey}, 3, awful.mouse.client.resize)
                                       )
     },
  }
  #+end_src 
** Shifty default tag creation rules   
#+begin_src lua
     -- SHIFTY: default tag creation rules
     -- parameter description
     --  * floatBars : if floating clients should always have a titlebar
     --  * guess_name : should shifty try and guess tag names when creating
     --                 new (unconfigured) tags?
     --  * guess_position: as above, but for position parameter
     --  * run : function to exec when shifty creates a new tag
     --  * all other parameters (e.g. layout, mwfact) follow awesome's tag API
     shifty.config.defaults = {
        layout = awful.layout.suit.tile.bottom,
        ncol = 1,
        mwfact = 0.60,
        floatBars = true,
        guess_name = true,
        guess_position = true,
        persist = false,
     }
  #+end_src 
** Define widgets
*** mytextclock
The default one
#+begin_src lua
     --  Wibox
     -- Create a textbox widget
     mytextclock = awful.widget.textclock({align = "right"})
#+end_src 
*** Menu
**** myawesomemenu
  #+begin_src lua
    myawesomemenu = {
       { "manual", env.terminal .. " -e man awesome" },
       { "edit config", env.editor .. " " .. awful.util.getdir("config") .. "/rc.lua.org" },
       { "restart", awesome.restart },
       { "quit", awesome.quit }
    }
    
#+end_src 
**** myquitmenu
#+begin_src lua 
  myquitmenu = {
     { "&Poweroff", env.poweroff }, 
     { "&Reboot", env.reboot }, 
     { "&Hibernate", env.hibernate }, 
     { "&Suspend", env.suspend }, 
     { "&Logout", awesome.quit },
     { "Logout &GNOME", env.logoutGnome }
  }
#+end_src
**** mymainmenu 
#+begin_src lua
  mymainmenu = awful.menu({ items = { 
                               { "awesome", myawesomemenu, beautiful.awesome_icon },
                               -- { "Debian", debian.menu.Debian_menu.Debian },
                               { "open terminal", env.terminal },
                               { "", nil, nil}, --separator
                               { "&quit", myquitmenu },
                                    }
                          })
#+end_src  
*** mylauncher
#+begin_src lua 
  mylauncher = awful.widget.launcher({image = image(beautiful.awesome_icon),
                                      menu = mymainmenu})
#+end_src 
*** mysystray
#+begin_src lua
     -- Create a systray
     mysystray = widget({type = "systray", align = "right"})
#+end_src 
*** mytaglist
#+begin_src lua 
  mytaglist = {}
  mytaglist.buttons = awful.util.table.join(
     awful.button({}, 1, awful.tag.viewonly),
     awful.button({modkey}, 1, awful.client.movetotag),
     awful.button({}, 3, function(tag) tag.selected = not tag.selected end),
     awful.button({modkey}, 3, awful.client.toggletag),
     awful.button({}, 4, awful.tag.viewnext),
     awful.button({}, 5, awful.tag.viewprev)
                                           )
  #+end_src
*** mytasklist
#+begin_src lua 
  mytasklist = {}
  mytasklist.buttons = awful.util.table.join(
     awful.button({}, 1, function(c)
                     if not c:isvisible() then
                        awful.tag.viewonly(c:tags()[1])
                     end
                     client.focus = c
                     c:raise()
                         end),
     awful.button({}, 3, function()
                     if instance then
                        instance:hide()
                        instance = nil
                     else
                        instance = awful.menu.clients({width=250})
                     end
                         end),
     awful.button({}, 4, function()
                     awful.client.focus.byidx(1)
                     if client.focus then client.focus:raise() end
                         end),
     awful.button({}, 5, function()
                     awful.client.focus.byidx(-1)
                     if client.focus then client.focus:raise() end
                         end))
#+end_src
** Create wibox for each screen and add it
  #+begin_src lua
    -- Create a wibox for each screen and add it
    mywibox = {}
    mypromptbox = {}
    mylayoutbox = {}
    
    for s = 1, screen.count() do
       -- Create a promptbox for each screen
       mypromptbox[s] =
          awful.widget.prompt({layout = awful.widget.layout.leftright})
       -- Create an imagebox widget which will contains an icon indicating which
       -- layout we're using.  We need one layoutbox per screen.
       mylayoutbox[s] = awful.widget.layoutbox(s)
       mylayoutbox[s]:buttons(awful.util.table.join(
                                 awful.button({}, 1, function() awful.layout.inc(layouts, 1) end),
                                 awful.button({}, 3, function() awful.layout.inc(layouts, -1) end),
                                 awful.button({}, 4, function() awful.layout.inc(layouts, 1) end),
                                 awful.button({}, 5, function() awful.layout.inc(layouts, -1) end)))
       -- Create a taglist widget
       mytaglist[s] = awful.widget.taglist.new(s,
                                               awful.widget.taglist.label.all,
                                               mytaglist.buttons)
       
       -- Create a tasklist widget
       mytasklist[s] = awful.widget.tasklist.new(function(c)
                                                    return awful.widget.tasklist.label.currenttags(c, s)
                                                 end,
                                                 mytasklist.buttons)
       
       -- Create the wibox
       mywibox[s] = awful.wibox({position = "top", screen = s})
       -- Add widgets to the wibox - order matters
       mywibox[s].widgets = {
          {
             mylauncher,
             mylayoutbox[s],
             mytaglist[s],
             mypromptbox[s],
             layout = awful.widget.layout.horizontal.leftright
          },
          mytextclock,
          s == 1 and mysystray or nil,
          mytasklist[s],
          layout = awful.widget.layout.horizontal.rightleft
       }
       
       mywibox[s].screen = s
    end
#+end_src 
** Shifty initialize  
#+begin_src lua
     -- SHIFTY: initialize shifty
     -- the assignment of shifty.taglist must always be after its actually
     -- initialized with awful.widget.taglist.new()
     shifty.taglist = mytaglist
     shifty.init()
  #+end_src 
** Mouse bindings
*** Global buttons
#+begin_src lua
     -- Mouse bindings
     root.buttons({
                     awful.button({}, 1, function () mymainmenu:hide() end),
                     awful.button({}, 3, function() mymainmenu:toggle() end),
                     awful.button({}, 4, awful.tag.viewnext),
                     awful.button({}, 5, awful.tag.viewprev)
                  })
  #+end_src 
*** Client buttons
**** Load ./module/clientbuttons.lua
#+begin_src lua 
  dofile(config .. "/clientbuttons.lua")
#+end_src

** Key bindings
*** Load ./module/globalkeys.lua
#+begin_src lua 
  dofile(config .. "/globalkeys.lua")
#+end_src

*** Add to the already defined keys
#+begin_src lua 
  globalkeys = awful.util.table.join(
     globalkeys,
     -- Shifty: keybindings specific to shifty
     awful.key({modkey, "Shift"}, "d", shifty.del), -- delete a tag
     awful.key({modkey, "Shift"}, "a", shifty.add), -- create a new tag
     awful.key({modkey, "Shift"}, "r", shifty.rename), -- rename a tag
     -- awful.key({modkey, "Shift"}, "a", -- nopopup new tag
     --    function()
     --    shifty.add({nopopup = true})
     --    end)
  
     awful.key({modkey, }, "F1", shifty.send_prev), -- client to prev tag
     awful.key({modkey  }, "F2", shifty.send_next), -- client to next tag
     awful.key({modkey, "Control"}, "n", 
               function()
                  shifty.tagtoscr(awful.util.cycle(screen.count(), mouse.screen + 1))
               end) -- move client to next tag
                                    )
  -- Compute the maximum number of digit we need, limited to 9
  for i = 1, (shifty.config.maxtags or 9) do
     globalkeys = awful.util.table.join(
        globalkeys,
        awful.key(
           {modkey}, i, 
           function()
              local t =  awful.tag.viewonly(shifty.getpos(i))
           end),
        awful.key(
           {modkey, "Control"}, i, 
           function()
              local t = shifty.getpos(i)
              t.selected = not t.selected
           end),
        awful.key(
           {modkey, "Control", "Shift"}, i, 
           function()
              if client.focus then
                 awful.client.toggletag(shifty.getpos(i))
              end
           end),
        -- move clients to other tags
        awful.key(
           {modkey, "Shift"}, i, 
           function()
              if client.focus then
                 t = shifty.getpos(i)
                 awful.client.movetotag(t)
                 awful.tag.viewonly(t)
              end
           end)
                                       )
  
  end
  #+end_src 

*** Set Global keys
#+begin_src lua
  -- Set keys
  root.keys(globalkeys)
  #+end_src 
*** Clients keys
**** Load ./module/clientkeys.lua
#+begin_src lua 
  dofile(config .. "/clientkeys.lua")
#+end_src

*** Shifty specific client keys
#+begin_src lua    
  -- SHIFTY: assign client keys to shifty for use in
  -- match() function(manage hook)
  shifty.config.clientkeys = clientkeys
  shifty.config.modkey = modkey
#+end_src

** Signals
*** Load predifined hooks (signals)
#+begin_src lua 
  dofile(config .. "/hooks.lua")
#+end_src

** Autostart
#+begin_src lua
  -- awful.util.spawn_with_shell("~/adjustMonitor")
  -- awful.util.spawn_with_shell("/usr/bin/lxpanel")
  -- awful.util.spawn_with_shell("/usr/bin/avant-window-navigator")
  -- awful.util.spawn_with_shell("setxkbmap -option compose:caps")
  -- awful.util.spawn_with_shell("gnome-settings-daemon && dex -a -e Awesome")
  -- r.run("gnome-settings-daemon")
  r.run("~/.config/awesome/autostart.sh")
#+end_src


* Acknowledgements
- switch tags on other screen:http://article.gmane.org/gmane.comp.window-managers.awesome/8807
 

* TODOs
** TODO Use additional files
Putt sections like keybindings which I would like to keep the same throughout different configs into separate file which can be linked in.
- revision :: %![Error: (wrong-type-argument symbolp master)]
- state    :: edited
- link     :: [[file:~/.config/awesome.awesomerc-rkrug/rc.lua.org::*Key%20bindings][Key bindings]] 
- author   :: Rainer M Krug, email: Rainer@krugs.de
** DONE Incorporate shifty
- Remove tagman
- activate shifty sections (already included but not tangled)
- state    :: edited
- link     :: [[file:~/.config/awesome/rc.lua.org::*rc.lua][rc.lua]] 
- author   :: Rainer M Krug, email: Rainer@krugs.de
* CHANGES
** <2012-05-25 Fri 17:30> Moving of certain elements into separate files
Keybindings and hooks were moved into seperate files in ./modules/ directory. This enables the utilisation of the same keybindings in different configs.
- author   :: Rainer M Krug, email: Rainer@krugs.de Rainer M. Krug

** <2012-05-28 Mon 10:52> Moved freedesktop and myrc into General Modules 
- link     :: [[file:~/.config/awesome.awesomerc-rkrug/rc.lua.org::*Include%20libraries][Include libraries]] 
- author   :: Rainer M Krug, email: Rainer@krugs.de Rainer M. Krug

** <2012-05-28 Mon 10:53> Moved systray and bottom wibox to math.max(screen.count(), 1)
This will cause them to appear on the laptop screen
- link     :: [[file:~/.config/awesome.awesomerc-rkrug/rc.lua.org::*Wibox][Wibox]] 
- author   :: Rainer M Krug, email: Rainer@krugs.de Rainer M. Krug
** <2012-05-29 Tue 10:18> Added sloppy-focus 
based on https://bbs.archlinux.org/viewtopic.php?id=83308 
- link     :: [[file:~/.config/awesome/rc.lua.org::*mouse_enter][mouse_enter]] 
- author   :: Rainer M Krug, email: Rainer@krugs.de Rainer M. Krug
